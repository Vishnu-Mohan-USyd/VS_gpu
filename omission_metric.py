"""Omission response metric — conductance-based (Gavornik & Bear 2014 style).

Computes the omission response as the difference in mean E→E excitatory
conductance (g_exc_ee) during the omitted-element window between a
trained-context trial and a control-context trial.

The control condition replaces the element *before* the omission with a
novel orientation not present in the training sequence, following G&B 2014's
design: the key prediction signal comes from element N→N+1 forward chains,
so disrupting the preceding element removes the learned predictive drive.
"""

import numpy as np
import jax
from network_jax import (
    run_sequence_trial_jax,
    reset_state_jax,
)


def _pick_novel_theta(seq_thetas: list, margin: float = 30.0) -> float:
    """Choose an orientation not in seq_thetas, at least `margin` degrees away.

    Parameters
    ----------
    seq_thetas : list of float
        Orientations used in the training sequence (degrees).
    margin : float
        Minimum angular distance (in degrees) from any training orientation.

    Returns
    -------
    float
        A novel orientation in [0, 180) degrees.
    """
    candidates = np.arange(0, 180, 5.0)
    seq_arr = np.array(seq_thetas)
    for cand in candidates:
        # circular distance on [0, 180)
        diffs = np.abs(seq_arr - cand)
        diffs = np.minimum(diffs, 180.0 - diffs)
        if diffs.min() >= margin:
            return float(cand)
    # fallback: pick the one maximizing minimum distance
    best = 0.0
    best_dist = 0.0
    for cand in candidates:
        diffs = np.abs(seq_arr - cand)
        diffs = np.minimum(diffs, 180.0 - diffs)
        if diffs.min() > best_dist:
            best_dist = diffs.min()
            best = float(cand)
    return best


def evaluate_omission_response(
    state,
    static,
    seq_thetas: list,
    element_ms: float,
    iti_ms: float,
    contrast: float = 1.0,
    omit_index: int = 1,
    n_repeats: int = 10,
    ctrl_thetas: list = None,
):
    """Compute omission response using conductance traces (g_exc_ee).

    Runs `n_repeats` omission-evaluation trials and averages the result
    for reliability.

    Parameters
    ----------
    state : SimState
        Current network state (weights, etc.).
    static : StaticConfig
        Static network configuration.
    seq_thetas : list of float
        Training sequence orientations (degrees), e.g. [0, 45, 90, 135].
    element_ms : float
        Duration of each sequence element (ms).
    iti_ms : float
        Inter-trial interval (ms).
    contrast : float
        Stimulus contrast.
    omit_index : int
        Which element to omit (0-indexed). Default=1 (2nd element).
    n_repeats : int
        Number of evaluation trials to average over.
    ctrl_thetas : list of float, optional
        Control sequence. If None, auto-generated by replacing the element
        before the omission with a novel orientation (G&B 2014 design).

    Returns
    -------
    dict with keys:
        'omission_response_conductance' : float
            Mean g_exc_ee difference (trained - control) in the omission window.
        'omission_response_spikes' : float
            Legacy spike-count difference for comparison.
        'n_eval_trials' : int
            Number of evaluation trials averaged.
        'trained_g_mean' : float
            Mean g_exc_ee in omission window (trained context).
        'control_g_mean' : float
            Mean g_exc_ee in omission window (control context).
        'trained_spk_mean' : float
            Mean spike count in omission window (trained context).
        'control_spk_mean' : float
            Mean spike count in omission window (control context).
    """
    if ctrl_thetas is None:
        # G&B 2014 control: replace element before omission with novel theta
        ctrl_thetas = list(seq_thetas)
        pre_omit = omit_index - 1 if omit_index > 0 else len(seq_thetas) - 1
        novel_theta = _pick_novel_theta(seq_thetas)
        ctrl_thetas[pre_omit] = novel_theta

    trained_g_vals = []
    control_g_vals = []
    trained_spk_vals = []
    control_spk_vals = []

    for _ in range(n_repeats):
        # Trained-context omission trial
        st_eval = reset_state_jax(state, static)
        _, info_omit = run_sequence_trial_jax(
            st_eval, static, seq_thetas, element_ms, iti_ms, contrast,
            'none', omit_index=omit_index,
        )
        # g_exc_ee_traces shape: (n_elem, element_steps, M)
        g_trained = np.array(info_omit['g_exc_ee_traces'][omit_index])  # (element_steps, M)
        trained_g_vals.append(g_trained.mean())
        trained_spk_vals.append(float(np.array(info_omit['element_counts'][omit_index]).sum()))

        # Control-context omission trial
        st_eval = reset_state_jax(state, static)
        _, info_ctrl = run_sequence_trial_jax(
            st_eval, static, ctrl_thetas, element_ms, iti_ms, contrast,
            'none', omit_index=omit_index,
        )
        g_control = np.array(info_ctrl['g_exc_ee_traces'][omit_index])  # (element_steps, M)
        control_g_vals.append(g_control.mean())
        control_spk_vals.append(float(np.array(info_ctrl['element_counts'][omit_index]).sum()))

    trained_g_mean = float(np.mean(trained_g_vals))
    control_g_mean = float(np.mean(control_g_vals))
    trained_spk_mean = float(np.mean(trained_spk_vals))
    control_spk_mean = float(np.mean(control_spk_vals))

    return {
        'omission_response_conductance': trained_g_mean - control_g_mean,
        'omission_response_spikes': trained_spk_mean - control_spk_mean,
        'n_eval_trials': n_repeats,
        'trained_g_mean': trained_g_mean,
        'control_g_mean': control_g_mean,
        'trained_spk_mean': trained_spk_mean,
        'control_spk_mean': control_spk_mean,
    }
